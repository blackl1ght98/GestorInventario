/*Métodos de extensión: Los métodos de extensión te permiten “agregar” métodos a tipos existentes 
         * sin crear un nuevo tipo derivado, recompilar o modificar de alguna otra manera el tipo original.
         * Son métodos estáticos, pero se llaman como si fueran métodos de instancia en el tipo extendido.
         * En este caso Paginar pasaria a formar parte de IQueryable
         */
 /*Pasos para crear un metodo de extension:
         1. La clase donde se realice el metodo de extension  tienen que ser estaticos
         2. Para decirle a .NET que admita cualquier tipo de dato se le pone <T> (InsertarParametrosPaginacionRespuesta<T>)
         3. Decimos de que clase de .NET va a extender este se indica asi (this HttpContext context)
         4. Decimos a .NET que tipo de dato va a admitir en este caso (IQueryable<T> queryable)
         */
        /*¿Que hace Httpcontext?
         * Su principal funcion es poder manipular y poder hacer distintas tareas con las peticiones http,
         * su definicion puede ser la siguiente HttpContext es una clase de .NET con la cual puedes manipular
         * una peticion http antes de enviarse.
         */
        /*El metodo que estamos creando es una extension de HttpContext con lo cual poniendo esto 
         * await HttpContext.InsertarParametrosPaginacionRespuesta(queryable, paginacion.CantidadAMostrar); podemos
         * acceder al metodo.
         */
        /*Para hacer un metodo de extension es decir que este dentro de una de las clases de .NET tenemos que hacer
          que esa clase sea estatica(public static class HttpContextExtensions), si la clase es estatica el metodo tambien
          lo tiene que ser que en este caso es InsertarParametrosPaginacionRespuesta.

          Esta clase  cuenta con lo siguiente:
              Lo primero que hacemos es establecer que va ha hacer nuestro metodo de extension que en este caso va a realizar una
              operacion asincrona  de tipo Task.  
        
              Nuestro metodo Task InsertarParametrosPaginacionRespuesta<T> va a poder admitir cualquier operacion asincrona siempre que esta 
              operacion asincrona devuleva algo de tipo IQueryable<T>.
              
              ¿Pero porque solo va a poder manejar IQueryable<T> si se ha dicho que <T> admite cualquier tipo de dato?
              Esto ocurre porque si nosotros tenemos la <T> InsertarParametrosPaginacionRespuesta<T> en nuestro metodo esto ahora admite cualquier tipo de 
              dato pero nosotros queremos limitar eso que acepte un determinado tipo de dato pues esto se determina en la parte del this() cuando en el 
              this() pones otra <T> this( IQueryable<T> queryable) estamos estableciendo una restriccion que puede decirse asi "Admite cualquier dato siempre que
              sea IQueryable".

              ¿Como decimos a .NET de que metodo extiende?
              Esto se especifica a lo primero del this() que en este caso es (this HttpContext context) pues nuestro metodo extiende de la clase
              HttpContext de .NET. 

              ¿Que significa que un metodo extienda de uno de .NET?
              Lo que significa que a ese metodo que tiene ya unas funciones le agregamos nuestras propias funcionalidades, lo cual es de gran ventaja para
              determinadas operaciones como por ejemplo la paginación en este caso nuestro metodo almacena en una cabecera llamada totalPaginas el numero
              total de paginas que tiene nuestra aplicacion web.
              
             ¿Porque solo admite IQueryable<T> y no otro metodo?
             Porque con esto permite construir consultas dinamicas que permiten el filtrado de datos entre otras cosas
             
            ¿Por que se usa los metodos genericos <T>?
            Esto se usa cuando no sabes que tipo de dato va a venir, me explico  <T> puede representas <Productos>, <Usuario> .... esto se usa para simplificar y 
            facilitar los metodos y evitar repeticion de codigo. Si solo se pone esta <T> puede tratar clases, estructuras.
            un tipo primitivo, etc. Cuando llamas a un método que devuelve T, obtienes un valor de ese tipo. Me explico si T en ese momento vale <Productos>
            el valor devuelto es algo de tipo <Productos>
            ¿Y cuando van de esta manera Task<T>?
            Este es exclusivo de operaciones asincronas que devuelven un valor

*/
Funcion Math.Ceiling():
 /* La función Math.Ceiling en .NET redondea un número hacia arriba al entero más cercano. 
              * Esta función es útil cuando necesitas redondear un número decimal hacia el entero más 
              * cercano que es mayor o igual al número dado.

              Por ejemplo, si tienes un número 2.4, Math.Ceiling(2.4) devolverá 3 porque 3 es el entero más grande que 
              es igual o mayor que 2.4. Si tienes un número -2.4, Math.Ceiling(-2.4) devolverá -2 porque -2 es 
              el entero más grande que es igual o mayor que -2.4.
              */
                public static async Task InsertarParametrosPaginacionRespuesta<T>(this HttpContext context, IQueryable<T> queryable, int cantidadRegistrosAMostrar)
        {
            // Si el contexto HTTP viene vacío, lanza una excepción
            if (context == null)
            {
                throw new ArgumentNullException(nameof(context));
            }

            // Cuenta el total de registros en la base de datos
            double conteo = await queryable.CountAsync();

            /* Divide el total de registros entre la cantidad de registros que se desean mostrar por página.
             * Math.Ceiling asegura que si el resultado es un decimal, se redondea al entero más cercano hacia arriba.
             * Por ejemplo, si hay 7 registros y se quieren mostrar 2 por página, el resultado sería 3.5 páginas,
             * pero como no puede haber medio página, Math.Ceiling redondea a 4 páginas.
             */
            double totalPaginas = Math.Ceiling(conteo / cantidadRegistrosAMostrar);

            // Agrega el total de páginas a la cabecera de la respuesta HTTP
            context.Response.Headers.Add("totalPaginas", totalPaginas.ToString());
        }
//........................................................................................................................
/* El método de extensión `Paginar<T>` aquí está diseñado para trabajar con cualquier tipo de dato `T` que pueda ser consultado a través de un IQueryable<T>.
         * Esto se indica en la firma del método: `public static IQueryable<T> Paginar<T>(this IQueryable<T> queryable, Paginacion paginacion)`.
         * Aquí, `IQueryable<T>` especifica que el método puede aceptar cualquier consulta de tipo `T` y también devolverá una consulta del mismo tipo.
         *
         * La `<T>` en `IQueryable<T>` y `Paginar<T>` es un marcador de posición para cualquier tipo. Esto significa que este método puede trabajar con 
         * cualquier tipo de dato, como `Productos`, `Usuarios`, `Proveedores`, etc., siempre que esos datos puedan ser consultados a través de un 
         * `IQueryable<T>`.
         *
         * Al usar este método de extensión en una consulta de tipo específico, por ejemplo, `IQueryable<Productos>`, el compilador reemplaza `T` por 
         * `Productos`, y el método se convierte en `Paginar<Productos>`, que acepta un `IQueryable<Productos>` y devuelve un `IQueryable<Productos>`.
         *
         * De esta manera, podemos tener un único método que puede manejar cualquier tipo de consulta, siempre que ese tipo de dato pueda ser consultado 
         * a través de un `IQueryable<T>`. Esto es útil para evitar la repetición de código y hacer que nuestro código sea más genérico y reutilizable.
         */
          public static IQueryable<T> Paginar<T>(this IQueryable<T> queryable, Paginacion paginacion)
        {
            // Calculamos cuántos elementos debemos omitir en la consulta.
            // Esto se hace multiplicando el número de la página (menos uno) por la cantidad de elementos que queremos mostrar en cada página.
            // Por ejemplo, si estamos en la página 1 (paginacion.Pagina es 1), entonces 1-1=0 y 0*cantidadRegistrosAMostrar da como resultado 0, por lo que no se omite ningún registro.
            // Si estamos en la página 2, entonces 2-1=1 y 1*cantidadRegistrosAMostrar da como resultado la cantidad de registros que se deben omitir.
            int skip = (paginacion.Pagina - 1) * paginacion.CantidadAMostrar;

            // Usamos el método Skip para omitir los elementos que ya hemos contado.
            // Luego usamos Take para seleccionar la cantidad de elementos que queremos mostrar.
            // De esta manera, obtenemos una "página" de resultados de nuestra consulta.
            return queryable.Skip(skip).Take(paginacion.CantidadAMostrar);
        }
//------------------------------------------------------------------------------------------------------------
